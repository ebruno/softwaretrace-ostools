<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Operating System Management Tools: child_management.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Operating System Management Tools
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('child__management_8md.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">child_management.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="child__management_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;# Child Process Management #</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;## Linux ##</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;When a process is created in UNIX using the fork() system call, the address space of the Parent process is replicated. </div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;If the parent process calls wait() system call, then the execution of parent is suspended until the child is terminated. </div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;At the termination of the child, a ‘SIGCHLD’ signal is generated which is delivered to the parent by the kernel. </div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;Parent, on receipt of ‘SIGCHLD’ reaps the status of the child from the process table. Even though, the child is terminated, </div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;there is an entry in the process table corresponding to the child where the status is stored. When parent collects the status, </div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;this entry is deleted. Thus, all the traces of the child process are removed from the system. If the parent decides not to </div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;wait for the child’s termination and it executes its subsequent task, then at the termination of the child, the exit status </div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;is not read. Hence, there remains an entry in the process table even after the termination of the child. </div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;This state of the child process is known as the Zombie state. </div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;### Zombie/Defunct Processes ###</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;With the advent of threaded programes the possibility of creating zombie processes increases. When a process is created in UNIX using the fork() system call, the address space of the parent process is replicated. The parent process has the option waiting for the child process to complete using the wait system call. When wait is called the execution of the parent is susspended until the child terminates. When the child terminates a &#39;SIGCHLD&#39; signal is generated and delivered to the parent by the kernel. The parent process on receipt of the &#39;SIGCHLD&#39; reaps the status of the child from the process table. In order to check asyncronously the waitpid system call is used. </div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;When the child is terminates, there is an entry in the process table corresponding to the child where the status is stored until the parent process collects the status.  Until the parent process reads the child process exit status the child process entry remains in this state is called the zombie state.  A process who&#39;s parent has not reaped it&#39;s exit status is a zombie process.</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;The following shell commands can be used to determine the zombie/defunct processes associated with process:</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;&lt;kbd&gt;ps -aef | grep &amp;lt;pid&amp;gt; | grep defunct&amp;lt;cr&amp;gt;&lt;/kbd&gt;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;   ebruno    13178  13177  0 18:09 pts/1    00:00:00 [demo_001] &lt;defunct&gt;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;   ebruno    13179  13177  0 18:09 pts/1    00:00:00 [demo_001] &lt;defunct&gt;</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;   ebruno    13180  13177  0 18:09 pts/1    00:00:00 [demo_001] &lt;defunct&gt;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;   ebruno    13181  13177  0 18:09 pts/1    00:00:00 [demo_001] &lt;defunct&gt;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;   ebruno    13182  13177  0 18:09 pts/1    00:00:00 [demo_001] &lt;defunct&gt;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;To just get the child pid&#39;s:</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;&lt;kbd&gt;ps -aef | grep &amp;lt;pid&amp;gt; | grep defunct | awk &#39;{print $2}&#39;&amp;lt;cr&amp;gt;&lt;/kbd&gt;</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;   13178</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;   13179</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;   13180</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;   13181</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;   13182</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;So the question is how can we get the same information, the standard API&#39;s available do not provide a way to get this information. </div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;Linux systems have the procfs, the information needed exists in this file system.</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;The ps program actually used the proc file system. It uses the file /proc/&amp;lt;pid&amp;gt;/stat a sample of information in this file is shown below:</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;The fields of interest to finding a processes children and the state of the child are fields 1, 3 and 4.  The pid, state and ppid fields.</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    351 (scsi_eh_5) S 2 0 0 0 -1 2138176 0 0 0 0 0 0 0 0 20 0 1 0 1271 0 0 18446744073709551615 0 0 0 0 0 0 0 2147483647 0 18446744073709551615 0 0 17 3 0 0 0 0 0 0 0 0 0 0 0 0 0</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;From the procfs man page:</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;The fields, in order, with their proper scanf(3) format specifiers, are:</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;  * pid %d      (1) The process ID.</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;  * comm %s     (2) The filename of the executable, in parentheses.  This is visible whether or not the executable is swapped out.</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;  * state %c    (3)  One  character  from  the string &quot;RSDZTW&quot; where R is running, S is sleeping in an interruptible wait, D is waiting in</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;            uninterruptible disk sleep, Z is zombie, T is traced or stopped (on a signal), and W is paging.</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    </div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;  * ppid %d     (4) The PID of the parent.</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;  </div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;  * pgrp %d     (5) The process group ID of the process.</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;  * session %d  (6) The session ID of the process.</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;  * tty_nr %d   (7) The controlling terminal of the process.  (The minor device number is contained in the combination of bits  31  to  20</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;            and 7 to 0; the major device number is in bits 15 to 8.)</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;  *  tpgid %d    (8) The ID of the foreground process group of the controlling terminal of the process.</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;  *  flags %u (%lu before Linux 2.6.22)</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;            (9)  The  kernel  flags  word  of  the  process.   For  bit meanings, see the PF_* defines in the Linux kernel source file</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;            include/linux/sched.h.  Details depend on the kernel version.</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;  *  minflt %lu  (10) The number of minor faults the process has made which have not required loading a memory page from disk.</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;  *  cminflt %lu (11) The number of minor faults that the process&#39;s waited-for children have made.</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;  *  majflt %lu  (12) The number of major faults the process has made which have required loading a memory page from disk.</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;  *  cmajflt %lu (13) The number of major faults that the process&#39;s waited-for children have made.</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;  *  utime %lu   (14) Amount  of  time  that  this  process  has  been  scheduled  in  user  mode,  measured  in  clock  ticks  (divide  by</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;            sysconf(_SC_CLK_TCK)).  This includes guest time, guest_time (time spent running a virtual CPU, see below), so that appli‐</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;            cations that are not aware of the guest time field do not lose that time from their calculations.</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;  *  stime %lu   (15) Amount of time  that  this  process  has  been  scheduled  in  kernel  mode,  measured  in  clock  ticks  (divide  by</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;            sysconf(_SC_CLK_TCK)).</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;  *  cutime %ld  (16)  Amount  of  time  that  this process&#39;s waited-for children have been scheduled in user mode, measured in clock ticks</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;            (divide by sysconf(_SC_CLK_TCK)).  (See also times(2).)  This includes guest time, cguest_time (time spent running a  vir‐</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;            tual CPU, see below).</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;  *  cstime %ld  (17)  Amount  of  time that this process&#39;s waited-for children have been scheduled in kernel mode, measured in clock ticks</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;            (divide by sysconf(_SC_CLK_TCK)).</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;  *  priority %ld</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;            (18) (Explanation for Linux 2.6) For processes running a real-time scheduling policy (policy  below;  see  sched_setsched‐</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;            uler(2)),  this is the negated scheduling priority, minus one; that is, a number in the range -2 to -100, corresponding to</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;            real-time priorities 1 to 99.  For processes running under a non-real-time scheduling policy, this is the raw  nice  value</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;            (setpriority(2))  as  represented  in  the  kernel.   The kernel stores nice values as numbers in the range 0 (high) to 39</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;            (low), corresponding to the user-visible nice range of -20 to 19. Before Linux 2.6, this was a scaled value based on the scheduler weighting given to this process.</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;  *  nice %ld (19) The nice value (see setpriority(2)), a value in the range 19 (low priority) to -20 (high priority).</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;  *  num_threads %ld</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;            (20) Number of threads in this process (since Linux 2.6).  Before kernel 2.6, this field was hard coded to 0 as  a  place‐</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;            holder for an earlier removed field.</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;  *  itrealvalue %ld</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;            (21)  The  time  in jiffies before the next SIGALRM is sent to the process due to an interval timer.  Since kernel 2.6.17,</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;            this field is no longer maintained, and is hard coded as 0.</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;  *  starttime %llu (was %lu before Linux 2.6)</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;            (22) The time the process started after system boot.  In kernels before Linux 2.6, this value was  expressed  in  jiffies.</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;            Since Linux 2.6, the value is expressed in clock ticks (divide by sysconf(_SC_CLK_TCK)).</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;  *  vsize %lu   (23) Virtual memory size in bytes.</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;  *  rss %ld     (24)  Resident  Set Size: number of pages the process has in real memory.  This is just the pages which count toward text,</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;             data, or stack space.  This does not include pages which have not been demand-loaded in, or which are swapped out.</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;  </div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;  *  rsslim %lu  (25) Current soft limit in bytes on the rss of the process; see the description of RLIMIT_RSS in getrlimit(2).</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;   </div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;  *  startcode %lu (26) The address above which program text can run.</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;   </div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;  *  endcode %lu (27) The address below which program text can run.</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;  </div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;  *  startstack %lu (28) The address of the start (i.e., bottom) of the stack.</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;   </div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;  *  kstkesp %lu (29) The current value of ESP (stack pointer), as found in the kernel stack page for the process.</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;  *  kstkeip %lu (30) The current EIP (instruction pointer).</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;   </div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;  *  signal %lu  (31) The bitmap of pending signals, displayed as a decimal number.  Obsolete, because it does not provide  information  on</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;             real-time signals; use /proc/[pid]/status instead.</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;   </div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;  *  blocked %lu (32)  The  bitmap of blocked signals, displayed as a decimal number.  Obsolete, because it does not provide information on</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;            real-time signals; use /proc/[pid]/status instead.</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;   </div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;  *  sigignore %lu (33) The bitmap of ignored signals, displayed as a decimal number.  Obsolete, because it does not provide  information  on</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;             real-time signals; use /proc/[pid]/status instead.</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;  *  sigcatch %lu (34)  The  bitmap  of caught signals, displayed as a decimal number.  Obsolete, because it does not provide information on</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;            real-time signals; use /proc/[pid]/status instead.</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;  *  wchan %lu   (35) This is the &quot;channel&quot; in which the process is waiting.  It is the address of a system call, and can be looked up in a</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;            namelist if you need a textual name.  (If you have an up-to-date /etc/psdatabase, then try ps -l to see the WCHAN field in</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;            action.)</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;  *  nswap %lu   (36) Number of pages swapped (not maintained).</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;  *  cnswap %lu  (37) Cumulative nswap for child processes (not maintained).</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;  *  exit_signal %d (since Linux 2.1.22)</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;            (38) Signal to be sent to parent when we die.</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;  *  processor %d (since Linux 2.2.8)</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;            (39) CPU number last executed on.</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;  *  rt_priority %u (since Linux 2.5.19; was %lu before Linux 2.6.22) (40) Real-time scheduling priority, a number in the range 1 to 99 for processes scheduled under a real-time policy, or  0,</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;            for non-real-time processes (see sched_setscheduler(2)).</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;  *  policy %u (since Linux 2.5.19; was %lu before Linux 2.6.22) (41) Scheduling policy (see sched_setscheduler(2)).  Decode using the SCHED_* constants in linux/sched.h.</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;  *  delayacct_blkio_ticks %llu (since Linux 2.6.18) (42) Aggregated block I/O delays, measured in clock ticks (centiseconds).</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;  *  guest_time %lu (since Linux 2.6.24) (43)  Guest  time  of the process (time spent running a virtual CPU for a guest operating system), measured in clock ticks (divide by sysconf(_SC_CLK_TCK)).     </div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;  *  cguest_time %ld (since Linux 2.6.24) (44) Guest time of the process&#39;s children, measured in clock ticks (divide by sysconf(_SC_CLK_TCK)).</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;  *  start_data %lu (since Linux 3.3) (45) Address above which program data+bss is placed.</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;  *  end_data %lu (since Linux 3.3) (46) Address below which program data+bss is placed.</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;  *  start_brk %lu (since Linux 3.3) (47) Address above which program heap can be expanded with brk().</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;  *  arg_start %lu (since Linux 3.5) (48) Address above which program command line is placed.</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;  *  arg_end %lu (since Linux 3.5) (49) Address below which program command line is placed.</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;  *  env_start %lu (since Linux 3.5) (50) Address above which program environment is placed.</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;  *  env_end %lu (since Linux 3.5) (51) Address below which program environment is placed.</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;  *  exit_code %d (since Linux 3.5) (52) The thread&#39;s exit_code in the form reported by the waitpid system.</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;pid_t waitpid(pid_t pid, int *status, int options);</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;Feature Test Macro Requirements for glibc (see feature_test_macros(7)):</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;waitid():</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;    SVID_SOURCE || _XOPEN_SOURCE &amp;gt;= 500 || _XOPEN_SOURCE &amp;&amp; _XOPEN_SOURCE_EXTENDED || /* Since glibc 2.12: */ _POSIX_C_SOURCE &gt;= 200809L</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;## FreeBSD ##</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;FreeBSD does not have the /proc file system as standard feature. However the procstat library is available. Which provides the same information.</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;From the man page:</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;The libprocstat library contains the API for runtime file and process information retrieval from   the running kernel via the sysctl(3) library</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;backend, and for post-mortem analysis via the kvm(3) library backend, or from the process core(5) file, searching for statistics in    special elf(3) note sections.</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;For more detail see [FreeBSD libprocstat man page](https://www.freebsd.org/cgi/man.cgi?query=libprocstat&amp;sektion=3&amp;apropos=0&amp;manpath=FreeBSD%2010.0-RELEASE &quot;FreeBSD libprocstat&quot;)</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;From [FreeBSD user.h source code](https://github.com/freebsd/freebsd/blob/master/sys/sys/user.h)</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;For child processes and zombies/defunct processing the fields that are of interest are </div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;``` ki_pid, ki_ppid and ki_stat. </div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;```</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;The structure returned is shown below:</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;```</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;struct kinfo_proc {</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;   int ki_structsize;      /* size of this structure */</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;   int ki_layout;      /* reserved: layout identifier */</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;   struct  pargs *ki_args;     /* address of command arguments */</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;   struct  proc *ki_paddr;     /* address of proc */</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;   struct  user *ki_addr;      /* kernel virtual addr of u-area */</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;   struct  vnode *ki_tracep;   /* pointer to trace file */</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;   struct  vnode *ki_textvp;   /* pointer to executable file */</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;   struct  filedesc *ki_fd;    /* pointer to open file info */</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;   struct  vmspace *ki_vmspace;    /* pointer to kernel vmspace struct */</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;   void    *ki_wchan;      /* sleep address */</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;   pid_t   ki_pid;         /* Process identifier */</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;   pid_t   ki_ppid;        /* parent process id */</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;   pid_t   ki_pgid;        /* process group id */</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;   pid_t   ki_tpgid;       /* tty process group id */</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;   pid_t   ki_sid;         /* Process session ID */</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;   pid_t   ki_tsid;        /* Terminal session ID */</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;   short   ki_jobc;        /* job control counter */</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;   short   ki_spare_short1;    /* unused (just here for alignment) */</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;   uint32_t ki_tdev_freebsd11; /* controlling tty dev */</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;   sigset_t ki_siglist;        /* Signals arrived but not delivered */</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;   sigset_t ki_sigmask;        /* Current signal mask */</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;   sigset_t ki_sigignore;      /* Signals being ignored */</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;   sigset_t ki_sigcatch;       /* Signals being caught by user */</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;   uid_t   ki_uid;         /* effective user id */</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;   uid_t   ki_ruid;        /* Real user id */</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;   uid_t   ki_svuid;       /* Saved effective user id */</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;   gid_t   ki_rgid;        /* Real group id */</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;   gid_t   ki_svgid;       /* Saved effective group id */</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;   short   ki_ngroups;     /* number of groups */</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;   short   ki_spare_short2;    /* unused (just here for alignment) */</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;   gid_t   ki_groups[KI_NGROUPS];  /* groups */</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;   vm_size_t ki_size;      /* virtual size */</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;   segsz_t ki_rssize;      /* current resident set size in pages */</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;   segsz_t ki_swrss;       /* resident set size before last swap */</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;   segsz_t ki_tsize;       /* text size (pages) XXX */</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;   segsz_t ki_dsize;       /* data size (pages) XXX */</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;   segsz_t ki_ssize;       /* stack size (pages) */</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;   u_short ki_xstat;       /* Exit status for wait &amp; stop signal */</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;   u_short ki_acflag;      /* Accounting flags */</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;   fixpt_t ki_pctcpu;      /* %cpu for process during ki_swtime */</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;   u_int   ki_estcpu;      /* Time averaged value of ki_cpticks */</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;   u_int   ki_slptime;     /* Time since last blocked */</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;   u_int   ki_swtime;      /* Time swapped in or out */</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;   u_int   ki_cow;         /* number of copy-on-write faults */</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;   u_int64_t ki_runtime;       /* Real time in microsec */</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;   struct  timeval ki_start;   /* starting time */</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;   struct  timeval ki_childtime;   /* time used by process children */</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;   long    ki_flag;        /* P_* flags */</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;   long    ki_kiflag;      /* KI_* flags (below) */</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;   int ki_traceflag;       /* Kernel trace points */</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;   char    ki_stat;        /* S* process status */</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;   signed char ki_nice;        /* Process &quot;nice&quot; value */</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;   char    ki_lock;        /* Process lock (prevent swap) count */</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;   char    ki_rqindex;     /* Run queue index */</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;   u_char  ki_oncpu_old;       /* Which cpu we are on (legacy) */</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;   u_char  ki_lastcpu_old;     /* Last cpu we were on (legacy) */</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;   char    ki_tdname[TDNAMLEN+1];  /* thread name */</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;   char    ki_wmesg[WMESGLEN+1];   /* wchan message */</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;   char    ki_login[LOGNAMELEN+1]; /* setlogin name */</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;   char    ki_lockname[LOCKNAMELEN+1]; /* lock name */</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;   char    ki_comm[COMMLEN+1]; /* command name */</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;   char    ki_emul[KI_EMULNAMELEN+1];  /* emulation name */</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;   char    ki_loginclass[LOGINCLASSLEN+1]; /* login class */</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;   char    ki_moretdname[MAXCOMLEN-TDNAMLEN+1];    /* more thread name */</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;   /*</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;    * When adding new variables, take space for char-strings from the</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;    * front of ki_sparestrings, and ints from the end of ki_spareints.</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;    * That way the spare room from both arrays will remain contiguous.</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;    */</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;   char    ki_sparestrings[46];    /* spare string space */</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;   int ki_spareints[KI_NSPARE_INT];    /* spare room for growth */</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;   uint64_t ki_tdev;       /* controlling tty dev */</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;   int ki_oncpu;       /* Which cpu we are on */</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;   int ki_lastcpu;     /* Last cpu we were on */</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;   int ki_tracer;      /* Pid of tracing process */</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;   int ki_flag2;       /* P2_* flags */</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;   int ki_fibnum;      /* Default FIB number */</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;   u_int   ki_cr_flags;        /* Credential flags */</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;   int ki_jid;         /* Process jail ID */</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;   int ki_numthreads;      /* XXXKSE number of threads in total */</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;   lwpid_t ki_tid;         /* XXXKSE thread id */</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;   struct  priority ki_pri;    /* process priority */</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;   struct  rusage ki_rusage;   /* process rusage statistics */</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;   /* XXX - most fields in ki_rusage_ch are not (yet) filled in */</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;   struct  rusage ki_rusage_ch;    /* rusage of children processes */</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;   struct  pcb *ki_pcb;        /* kernel virtual addr of pcb */</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;   void    *ki_kstack;     /* kernel virtual addr of stack */</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;   void    *ki_udata;      /* User convenience pointer */</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;   struct  thread *ki_tdaddr;  /* address of thread */</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;   /*</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;    * When adding new variables, take space for pointers from the</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;    * front of ki_spareptrs, and longs from the end of ki_sparelongs.</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;    * That way the spare room from both arrays will remain contiguous.</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;    */</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;   void    *ki_spareptrs[KI_NSPARE_PTR];   /* spare room for growth */</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;   long    ki_sparelongs[KI_NSPARE_LONG];  /* spare room for growth */</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;   long    ki_sflag;       /* PS_* flags */</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;   long    ki_tdflags;     /* XXXKSE kthread flag */</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;}; </div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;```</div></div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="child__management_8md.html">child_management.md</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
